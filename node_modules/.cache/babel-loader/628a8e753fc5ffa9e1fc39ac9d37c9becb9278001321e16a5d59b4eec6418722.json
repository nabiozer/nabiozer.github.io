{"ast":null,"code":"import { number as locale } from './locale';\nimport isAbsent from './util/isAbsent';\nimport BaseSchema from './schema';\nlet isNaN = value => value != +value;\nexport function create() {\n  return new NumberSchema();\n}\nexport default class NumberSchema extends BaseSchema {\n  constructor() {\n    super({\n      type: 'number'\n    });\n    this.withMutation(() => {\n      this.transform(function (value) {\n        let parsed = value;\n        if (typeof parsed === 'string') {\n          parsed = parsed.replace(/\\s/g, '');\n          if (parsed === '') return NaN; // don't use parseFloat to avoid positives on alpha-numeric strings\n\n          parsed = +parsed;\n        }\n        if (this.isType(parsed)) return parsed;\n        return parseFloat(parsed);\n      });\n    });\n  }\n  _typeCheck(value) {\n    if (value instanceof Number) value = value.valueOf();\n    return typeof value === 'number' && !isNaN(value);\n  }\n  min(min) {\n    let message = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : locale.min;\n    return this.test({\n      message,\n      name: 'min',\n      exclusive: true,\n      params: {\n        min\n      },\n      test(value) {\n        return isAbsent(value) || value >= this.resolve(min);\n      }\n    });\n  }\n  max(max) {\n    let message = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : locale.max;\n    return this.test({\n      message,\n      name: 'max',\n      exclusive: true,\n      params: {\n        max\n      },\n      test(value) {\n        return isAbsent(value) || value <= this.resolve(max);\n      }\n    });\n  }\n  lessThan(less) {\n    let message = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : locale.lessThan;\n    return this.test({\n      message,\n      name: 'max',\n      exclusive: true,\n      params: {\n        less\n      },\n      test(value) {\n        return isAbsent(value) || value < this.resolve(less);\n      }\n    });\n  }\n  moreThan(more) {\n    let message = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : locale.moreThan;\n    return this.test({\n      message,\n      name: 'min',\n      exclusive: true,\n      params: {\n        more\n      },\n      test(value) {\n        return isAbsent(value) || value > this.resolve(more);\n      }\n    });\n  }\n  positive() {\n    let msg = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : locale.positive;\n    return this.moreThan(0, msg);\n  }\n  negative() {\n    let msg = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : locale.negative;\n    return this.lessThan(0, msg);\n  }\n  integer() {\n    let message = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : locale.integer;\n    return this.test({\n      name: 'integer',\n      message,\n      test: val => isAbsent(val) || Number.isInteger(val)\n    });\n  }\n  truncate() {\n    return this.transform(value => !isAbsent(value) ? value | 0 : value);\n  }\n  round(method) {\n    var _method;\n    let avail = ['ceil', 'floor', 'round', 'trunc'];\n    method = ((_method = method) == null ? void 0 : _method.toLowerCase()) || 'round'; // this exists for symemtry with the new Math.trunc\n\n    if (method === 'trunc') return this.truncate();\n    if (avail.indexOf(method.toLowerCase()) === -1) throw new TypeError('Only valid options for round() are: ' + avail.join(', '));\n    return this.transform(value => !isAbsent(value) ? Math[method](value) : value);\n  }\n}\ncreate.prototype = NumberSchema.prototype; //\n// Number Interfaces\n//","map":{"version":3,"names":["number","locale","isAbsent","BaseSchema","isNaN","value","create","NumberSchema","constructor","type","withMutation","transform","parsed","replace","NaN","isType","parseFloat","_typeCheck","Number","valueOf","min","message","arguments","length","undefined","test","name","exclusive","params","resolve","max","lessThan","less","moreThan","more","positive","msg","negative","integer","val","isInteger","truncate","round","method","_method","avail","toLowerCase","indexOf","TypeError","join","Math","prototype"],"sources":["/Users/nabiozer/Desktop/nabi/node_modules/yup/es/number.js"],"sourcesContent":["import { number as locale } from './locale';\nimport isAbsent from './util/isAbsent';\nimport BaseSchema from './schema';\n\nlet isNaN = value => value != +value;\n\nexport function create() {\n  return new NumberSchema();\n}\nexport default class NumberSchema extends BaseSchema {\n  constructor() {\n    super({\n      type: 'number'\n    });\n    this.withMutation(() => {\n      this.transform(function (value) {\n        let parsed = value;\n\n        if (typeof parsed === 'string') {\n          parsed = parsed.replace(/\\s/g, '');\n          if (parsed === '') return NaN; // don't use parseFloat to avoid positives on alpha-numeric strings\n\n          parsed = +parsed;\n        }\n\n        if (this.isType(parsed)) return parsed;\n        return parseFloat(parsed);\n      });\n    });\n  }\n\n  _typeCheck(value) {\n    if (value instanceof Number) value = value.valueOf();\n    return typeof value === 'number' && !isNaN(value);\n  }\n\n  min(min, message = locale.min) {\n    return this.test({\n      message,\n      name: 'min',\n      exclusive: true,\n      params: {\n        min\n      },\n\n      test(value) {\n        return isAbsent(value) || value >= this.resolve(min);\n      }\n\n    });\n  }\n\n  max(max, message = locale.max) {\n    return this.test({\n      message,\n      name: 'max',\n      exclusive: true,\n      params: {\n        max\n      },\n\n      test(value) {\n        return isAbsent(value) || value <= this.resolve(max);\n      }\n\n    });\n  }\n\n  lessThan(less, message = locale.lessThan) {\n    return this.test({\n      message,\n      name: 'max',\n      exclusive: true,\n      params: {\n        less\n      },\n\n      test(value) {\n        return isAbsent(value) || value < this.resolve(less);\n      }\n\n    });\n  }\n\n  moreThan(more, message = locale.moreThan) {\n    return this.test({\n      message,\n      name: 'min',\n      exclusive: true,\n      params: {\n        more\n      },\n\n      test(value) {\n        return isAbsent(value) || value > this.resolve(more);\n      }\n\n    });\n  }\n\n  positive(msg = locale.positive) {\n    return this.moreThan(0, msg);\n  }\n\n  negative(msg = locale.negative) {\n    return this.lessThan(0, msg);\n  }\n\n  integer(message = locale.integer) {\n    return this.test({\n      name: 'integer',\n      message,\n      test: val => isAbsent(val) || Number.isInteger(val)\n    });\n  }\n\n  truncate() {\n    return this.transform(value => !isAbsent(value) ? value | 0 : value);\n  }\n\n  round(method) {\n    var _method;\n\n    let avail = ['ceil', 'floor', 'round', 'trunc'];\n    method = ((_method = method) == null ? void 0 : _method.toLowerCase()) || 'round'; // this exists for symemtry with the new Math.trunc\n\n    if (method === 'trunc') return this.truncate();\n    if (avail.indexOf(method.toLowerCase()) === -1) throw new TypeError('Only valid options for round() are: ' + avail.join(', '));\n    return this.transform(value => !isAbsent(value) ? Math[method](value) : value);\n  }\n\n}\ncreate.prototype = NumberSchema.prototype; //\n// Number Interfaces\n//"],"mappings":"AAAA,SAASA,MAAM,IAAIC,MAAM,QAAQ,UAAU;AAC3C,OAAOC,QAAQ,MAAM,iBAAiB;AACtC,OAAOC,UAAU,MAAM,UAAU;AAEjC,IAAIC,KAAK,GAAGC,KAAK,IAAIA,KAAK,IAAI,CAACA,KAAK;AAEpC,OAAO,SAASC,MAAMA,CAAA,EAAG;EACvB,OAAO,IAAIC,YAAY,EAAE;AAC3B;AACA,eAAe,MAAMA,YAAY,SAASJ,UAAU,CAAC;EACnDK,WAAWA,CAAA,EAAG;IACZ,KAAK,CAAC;MACJC,IAAI,EAAE;IACR,CAAC,CAAC;IACF,IAAI,CAACC,YAAY,CAAC,MAAM;MACtB,IAAI,CAACC,SAAS,CAAC,UAAUN,KAAK,EAAE;QAC9B,IAAIO,MAAM,GAAGP,KAAK;QAElB,IAAI,OAAOO,MAAM,KAAK,QAAQ,EAAE;UAC9BA,MAAM,GAAGA,MAAM,CAACC,OAAO,CAAC,KAAK,EAAE,EAAE,CAAC;UAClC,IAAID,MAAM,KAAK,EAAE,EAAE,OAAOE,GAAG,CAAC,CAAC;;UAE/BF,MAAM,GAAG,CAACA,MAAM;QAClB;QAEA,IAAI,IAAI,CAACG,MAAM,CAACH,MAAM,CAAC,EAAE,OAAOA,MAAM;QACtC,OAAOI,UAAU,CAACJ,MAAM,CAAC;MAC3B,CAAC,CAAC;IACJ,CAAC,CAAC;EACJ;EAEAK,UAAUA,CAACZ,KAAK,EAAE;IAChB,IAAIA,KAAK,YAAYa,MAAM,EAAEb,KAAK,GAAGA,KAAK,CAACc,OAAO,EAAE;IACpD,OAAO,OAAOd,KAAK,KAAK,QAAQ,IAAI,CAACD,KAAK,CAACC,KAAK,CAAC;EACnD;EAEAe,GAAGA,CAACA,GAAG,EAAwB;IAAA,IAAtBC,OAAO,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAGrB,MAAM,CAACmB,GAAG;IAC3B,OAAO,IAAI,CAACK,IAAI,CAAC;MACfJ,OAAO;MACPK,IAAI,EAAE,KAAK;MACXC,SAAS,EAAE,IAAI;MACfC,MAAM,EAAE;QACNR;MACF,CAAC;MAEDK,IAAIA,CAACpB,KAAK,EAAE;QACV,OAAOH,QAAQ,CAACG,KAAK,CAAC,IAAIA,KAAK,IAAI,IAAI,CAACwB,OAAO,CAACT,GAAG,CAAC;MACtD;IAEF,CAAC,CAAC;EACJ;EAEAU,GAAGA,CAACA,GAAG,EAAwB;IAAA,IAAtBT,OAAO,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAGrB,MAAM,CAAC6B,GAAG;IAC3B,OAAO,IAAI,CAACL,IAAI,CAAC;MACfJ,OAAO;MACPK,IAAI,EAAE,KAAK;MACXC,SAAS,EAAE,IAAI;MACfC,MAAM,EAAE;QACNE;MACF,CAAC;MAEDL,IAAIA,CAACpB,KAAK,EAAE;QACV,OAAOH,QAAQ,CAACG,KAAK,CAAC,IAAIA,KAAK,IAAI,IAAI,CAACwB,OAAO,CAACC,GAAG,CAAC;MACtD;IAEF,CAAC,CAAC;EACJ;EAEAC,QAAQA,CAACC,IAAI,EAA6B;IAAA,IAA3BX,OAAO,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAGrB,MAAM,CAAC8B,QAAQ;IACtC,OAAO,IAAI,CAACN,IAAI,CAAC;MACfJ,OAAO;MACPK,IAAI,EAAE,KAAK;MACXC,SAAS,EAAE,IAAI;MACfC,MAAM,EAAE;QACNI;MACF,CAAC;MAEDP,IAAIA,CAACpB,KAAK,EAAE;QACV,OAAOH,QAAQ,CAACG,KAAK,CAAC,IAAIA,KAAK,GAAG,IAAI,CAACwB,OAAO,CAACG,IAAI,CAAC;MACtD;IAEF,CAAC,CAAC;EACJ;EAEAC,QAAQA,CAACC,IAAI,EAA6B;IAAA,IAA3Bb,OAAO,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAGrB,MAAM,CAACgC,QAAQ;IACtC,OAAO,IAAI,CAACR,IAAI,CAAC;MACfJ,OAAO;MACPK,IAAI,EAAE,KAAK;MACXC,SAAS,EAAE,IAAI;MACfC,MAAM,EAAE;QACNM;MACF,CAAC;MAEDT,IAAIA,CAACpB,KAAK,EAAE;QACV,OAAOH,QAAQ,CAACG,KAAK,CAAC,IAAIA,KAAK,GAAG,IAAI,CAACwB,OAAO,CAACK,IAAI,CAAC;MACtD;IAEF,CAAC,CAAC;EACJ;EAEAC,QAAQA,CAAA,EAAwB;IAAA,IAAvBC,GAAG,GAAAd,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAGrB,MAAM,CAACkC,QAAQ;IAC5B,OAAO,IAAI,CAACF,QAAQ,CAAC,CAAC,EAAEG,GAAG,CAAC;EAC9B;EAEAC,QAAQA,CAAA,EAAwB;IAAA,IAAvBD,GAAG,GAAAd,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAGrB,MAAM,CAACoC,QAAQ;IAC5B,OAAO,IAAI,CAACN,QAAQ,CAAC,CAAC,EAAEK,GAAG,CAAC;EAC9B;EAEAE,OAAOA,CAAA,EAA2B;IAAA,IAA1BjB,OAAO,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAGrB,MAAM,CAACqC,OAAO;IAC9B,OAAO,IAAI,CAACb,IAAI,CAAC;MACfC,IAAI,EAAE,SAAS;MACfL,OAAO;MACPI,IAAI,EAAEc,GAAG,IAAIrC,QAAQ,CAACqC,GAAG,CAAC,IAAIrB,MAAM,CAACsB,SAAS,CAACD,GAAG;IACpD,CAAC,CAAC;EACJ;EAEAE,QAAQA,CAAA,EAAG;IACT,OAAO,IAAI,CAAC9B,SAAS,CAACN,KAAK,IAAI,CAACH,QAAQ,CAACG,KAAK,CAAC,GAAGA,KAAK,GAAG,CAAC,GAAGA,KAAK,CAAC;EACtE;EAEAqC,KAAKA,CAACC,MAAM,EAAE;IACZ,IAAIC,OAAO;IAEX,IAAIC,KAAK,GAAG,CAAC,MAAM,EAAE,OAAO,EAAE,OAAO,EAAE,OAAO,CAAC;IAC/CF,MAAM,GAAG,CAAC,CAACC,OAAO,GAAGD,MAAM,KAAK,IAAI,GAAG,KAAK,CAAC,GAAGC,OAAO,CAACE,WAAW,EAAE,KAAK,OAAO,CAAC,CAAC;;IAEnF,IAAIH,MAAM,KAAK,OAAO,EAAE,OAAO,IAAI,CAACF,QAAQ,EAAE;IAC9C,IAAII,KAAK,CAACE,OAAO,CAACJ,MAAM,CAACG,WAAW,EAAE,CAAC,KAAK,CAAC,CAAC,EAAE,MAAM,IAAIE,SAAS,CAAC,sCAAsC,GAAGH,KAAK,CAACI,IAAI,CAAC,IAAI,CAAC,CAAC;IAC9H,OAAO,IAAI,CAACtC,SAAS,CAACN,KAAK,IAAI,CAACH,QAAQ,CAACG,KAAK,CAAC,GAAG6C,IAAI,CAACP,MAAM,CAAC,CAACtC,KAAK,CAAC,GAAGA,KAAK,CAAC;EAChF;AAEF;AACAC,MAAM,CAAC6C,SAAS,GAAG5C,YAAY,CAAC4C,SAAS,CAAC,CAAC;AAC3C;AACA"},"metadata":{},"sourceType":"module","externalDependencies":[]}